"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2621],{3905:(n,e,o)=>{o.d(e,{Zo:()=>c,kt:()=>m});var a=o(7294);function t(n,e,o){return e in n?Object.defineProperty(n,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[e]=o,n}function i(n,e){var o=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),o.push.apply(o,a)}return o}function s(n){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?i(Object(o),!0).forEach((function(e){t(n,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(o,e))}))}return n}function r(n,e){if(null==n)return{};var o,a,t=function(n,e){if(null==n)return{};var o,a,t={},i=Object.keys(n);for(a=0;a<i.length;a++)o=i[a],e.indexOf(o)>=0||(t[o]=n[o]);return t}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)o=i[a],e.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(n,o)&&(t[o]=n[o])}return t}var p=a.createContext({}),l=function(n){var e=a.useContext(p),o=e;return n&&(o="function"==typeof n?n(e):s(s({},e),n)),o},c=function(n){var e=l(n.components);return a.createElement(p.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},_=a.forwardRef((function(n,e){var o=n.components,t=n.mdxType,i=n.originalType,p=n.parentName,c=r(n,["components","mdxType","originalType","parentName"]),_=l(o),m=t,w=_["".concat(p,".").concat(m)]||_[m]||u[m]||i;return o?a.createElement(w,s(s({ref:e},c),{},{components:o})):a.createElement(w,s({ref:e},c))}));function m(n,e){var o=arguments,t=e&&e.mdxType;if("string"==typeof n||t){var i=o.length,s=new Array(i);s[0]=_;var r={};for(var p in e)hasOwnProperty.call(e,p)&&(r[p]=e[p]);r.originalType=n,r.mdxType="string"==typeof n?n:t,s[1]=r;for(var l=2;l<i;l++)s[l]=o[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,o)}_.displayName="MDXCreateElement"},917:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var a=o(7462),t=(o(7294),o(3905));const i={},s="Examples for contracts",r={unversionedId:"contracts/Aptos/Swap/swap_examples",id:"contracts/Aptos/Swap/swap_examples",title:"Examples for contracts",description:"Update your Move.toml with",source:"@site/docs/contracts/Aptos/Swap/swap_examples.md",sourceDirName:"contracts/Aptos/Swap",slug:"/contracts/Aptos/Swap/swap_examples",permalink:"/docs/contracts/Aptos/Swap/swap_examples",draft:!1,editUrl:"https://github.com/AnimeSwap/docs/blob/main/docs/contracts/Aptos/Swap/swap_examples.md",tags:[],version:"current",frontMatter:{},sidebar:"contracts",previous:{title:"Events",permalink:"/docs/contracts/Aptos/Swap/swap_events"},next:{title:"Entry Functions",permalink:"/docs/contracts/Aptos/MasterChef/masterchef_api"}},p={},l=[{value:"Key public functions",id:"key-public-functions",level:2},{value:"Swap example",id:"swap-example",level:2},{value:"Flash swap example:",id:"flash-swap-example",level:2}],c={toc:l};function u(n){let{components:e,...o}=n;return(0,t.kt)("wrapper",(0,a.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"examples-for-contracts"},"Examples for contracts"),(0,t.kt)("p",null,"Update your ",(0,t.kt)("inlineCode",{parentName:"p"},"Move.toml")," with"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-toml"},"[dependencies.AnimeSwap]\ngit = 'https://github.com/AnimeSwap/v1-core.git'\nrev = 'v1.0.0'\nsubdir = 'Swap'\n")),(0,t.kt)("h2",{id:"key-public-functions"},"Key public functions"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-move"},"/// Swap X to Y\n/// swap from X to Y\npublic fun swap_coins_for_coins<X, Y>(\n    coins_in: Coin<X>,\n): Coin<Y>\n\n/// Create pair, and register events\n/// require X < Y\npublic fun create_pair<X, Y>()\n\n/// Add liquidity\n/// require X < Y\npublic fun add_liquidity<X, Y>(\n    account: &signer,\n    amount_x_desired: u64,\n    amount_y_desired: u64,\n    amount_x_min: u64,\n    amount_y_min: u64,\n)\n\n/// Remove liquidity\n/// require X < Y\npublic fun remove_liquidity<X, Y>(\n    coins: Coin<LPCoin<X, Y>>,\n    amount_x_min: u64,\n    amount_y_min: u64,\n): (Coin<X>, Coin<Y>)\n\n/// Get flash swap coins. User can loan any coins, and repay in the same tx.\n/// In most cases, user may loan one coin, and repay the same or the other coin.\n/// require X < Y.\n/// * `loan_coin_x` - expected amount of X coins to loan.\n/// * `loan_coin_y` - expected amount of Y coins to loan.\n/// Returns both loaned X and Y coins: `(Coin<X>, Coin<Y>, Flashloan<X, Y)`.\npublic fun flash_swap<X, Y>(\n    loan_coin_x: u64,\n    loan_coin_y: u64\n): (Coin<X>, Coin<Y>, FlashSwap<X, Y>)\n\n/// Repay flash swap coins.\n/// User should repay amount, following the conditions:\n/// `new_pool_1_value * new_pool_2_value >= old_pool_1_value * old_pool_2_value`\n/// where `new_pool_x_value` is the `old_pool_x_value - amount_out + amount_in * (1 - swapFee)`,\n/// and `pool_x_value` is the reserve amount for a given CoinType.\n/// * `x_in` - X coins to pay.\n/// * `y_in` - Y coins to pay.\n/// * `flash_swap` - flash_swap return.\npublic fun pay_flash_swap<X, Y>(\n    x_in: Coin<X>,\n    y_in: Coin<Y>,\n    flash_swap: FlashSwap<X, Y>\n)\n")),(0,t.kt)("h2",{id:"swap-example"},"Swap example"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-move"},"// swap exact coin to maximal coin\nuse SwapDeployer::AnimeSwapPoolV1;\n...\n// swap `amount_in` X to Y\nlet amount_in = 100000;\nlet coins_in = coin::withdraw(&account, amount_in);\nlet coins_out = AnimeSwapPoolV1::swap_coins_for_coins<X, Y>(coins_in);\n")),(0,t.kt)("p",null,"or"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-move"},"// swap minimal coin to exact coin (maybe some more dust)\nuse SwapDeployer::AnimeSwapPoolV1;\n...\n// swap X to `amount_out` Y\nlet amount_out = 100000;\nlet amount_in = AnimeSwapPoolV1::get_amounts_in_1_pair<X, Y>(amount_out);\n// check if `amount_in` meets your demand\nlet coins_in = coin::withdraw(&account, amount_in);\nlet coins_out = AnimeSwapPoolV1::swap_coins_for_coins<X, Y>(coins_in);\n// Because of discrete, coins_out value is actually `amount_out + dust`.\n// Our protocol does not keep the dust, but return to user instead.\nassert!(coin::value(&coins_out) >= amount_out, 1);\n")),(0,t.kt)("h2",{id:"flash-swap-example"},"Flash swap example:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-move"},"use SwapDeployer::AnimeSwapPoolV1Library;\nuse SwapDeployer::AnimeSwapPoolV1;\n...\n// loan `amount` Y and repay X\nlet amount = 100000;\nlet borrow_amount = AnimeSwapPoolV1::get_amounts_out_1_pair<X, Y>(amount);\nlet coins_out;\nif (AnimeSwapPoolV1Library::compare<X, Y>()) {\n    // flash loan Y\n    let (coins_in_zero, coins_in, flash_swap) = AnimeSwapPoolV1::flash_swap<X, Y>(0, borrow_amount);\n    coin::destroy_zero<X>(coins_in_zero);\n    // do something with coins_in and get coins_out\n    coins_out = f(coins_in);\n    // repay X\n    let repay_coins = coin::extract(&mut coins_out, amount);\n    AnimeSwapPoolV1::pay_flash_swap<X, Y>(repay_coins, coin::zero<Y>(), flash_swap);\n} else {\n    // flash loan Y\n    let (coins_in, coins_in_zero, flash_swap) = AnimeSwapPoolV1::flash_swap<Y, X>(borrow_amount, 0);\n    coin::destroy_zero<X>(coins_in_zero);\n    // do something with coins_in and get coins_out\n    coins_out = f(coins_in);\n    // repay X\n    let repay_coins = coin::extract(&mut coins_out, amount);\n    AnimeSwapPoolV1::pay_flash_swap<Y, X>(coin::zero<Y>(), repay_coins, flash_swap);\n};\n// keep the rest `coins_out`\n")),(0,t.kt)("p",null,"or"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-move"},"use SwapDeployer::AnimeSwapPoolV1Library;\nuse SwapDeployer::AnimeSwapPoolV1;\n...\n// loan `amount` X and repay Y\nlet amount = 100000;\nlet repay_amount = AnimeSwapPoolV1::get_amounts_in_1_pair<X, Y>(amount);\nlet coins_out;\nif (AnimeSwapPoolV1Library::compare<X, Y>()) {\n    // flash loan X\n    let (coins_in, coins_in_zero, flash_swap) = AnimeSwapPoolV1::flash_swap<X, Y>(amount, 0);\n    coin::destroy_zero<Y>(coins_in_zero);\n    // do something with coins_in and get coins_out\n    coins_out = f(coins_in);\n    // repay Y\n    let repay_coins = coin::extract(&mut coins_out, repay_amount);\n    AnimeSwapPoolV1::pay_flash_swap<X, Y>(coin::zero<X>(), repay_coins, flash_swap);\n} else {\n    // flash loan X\n    let (coins_in_zero, coins_in, flash_swap) = AnimeSwapPoolV1::flash_swap<Y, X>(0, amount);\n    coin::destroy_zero<Y>(coins_in_zero);\n    // do something with coins_in and get coins_out\n    coins_out = f(coins_in);\n    // repay Y\n    let repay_coins = coin::extract(&mut coins_out, repay_amount);\n    AnimeSwapPoolV1::pay_flash_swap<Y, X>(repay_coins, coin::zero<X>(), flash_swap);\n};\n// keep the rest `coins_out`\n")))}u.isMDXComponent=!0}}]);